\documentclass[a4paper,11pt]{report}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{lipsum}
\usepackage{hyperref,xcolor,fancyhdr}
\usepackage{graphicx}
\graphicspath{{Figuras/}}
\usepackage{url}
\usepackage{xspace}
\setlength{\parskip}{4mm}
\usepackage{listings}
\definecolor{gray92}{gray}{0.92}
\definecolor{black85}{rgb}{0.28,0.28,0.28}
\hypersetup{
  colorlinks   = true,
  urlcolor     = blue, 
  linkcolor    = black, 
  citecolor   = red 
}

\usepackage{pgfgantt}
\usepackage{pdflscape}



\begin{document}

\begin{titlepage}

\begin{center}
\vspace*{0.5in}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.7\textwidth]{uc3m}
\end{center}
\end{figure}
\vspace*{1in}
Universidad Carlos III de Madrid - Escuela Politécnica Superior \\
Grado en Ingeniería Informática \\
Seguridad en dispositivos móviles \\

\vspace*{0.1in}
\emph{Grupo de investigación: Computer Security Lab}  \\

\vspace*{1.2in}
\begin{huge}
\textbf{Android botnets for multi-targeted attacks} \\
\end{huge}


\end{center}

\vfill
\begin{center}
Autores:\\
\textbf{Adán Cano Moreno. NIA: 100346105.}\\
\textbf{Jaime García González. NIA: 100346062.}\\
\vspace*{0.2in}
Grupo: \textbf{81.}\\
\vspace*{1in}
\today
\end{center}


\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\chapter{Resumen}
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}
\pagestyle{fancy}


%% Descripción de tareas

A continuación, se detallan las tareas realizadas por cada uno de los integrantes del grupo.

\section*{Jaime}

\begin{description}
\item[Trabajos previos.] Lectura de trabajos previos obtenidos de la bibliografía del artículo. Redacción del Capítulo \ref{tPrevios}.
\item[Trabajos posteriores.] Búsqueda y lectura de trabajos posteriores. Redacción del Capítulo \ref{tPosteriores}.
\item[Conclusiones.] Redacción del Capítulo \ref{conclusiones}.
\item[Planificación.] Realización del diagrama de Gantt de la sección \ref{planificacion} con la herramienta \emph{pgfgantt}.
\item[Glosario.] Búsqueda de términos importantes del documento y redacción del Capítulo \ref{glosario}.
\item[Bibliografía.] Realización de la bibliografía del documento con la herramienta Bib\LaTeX.
\end{description}

\section*{Adán}

%El presente artículo expone el procedimiento a seguir para realizar un ataque \emph{botnet} eficiente sobre diferentes dispositivos móviles \emph{Android} al mismo tiempo para capturar información. El desarrollo del artículo se debe a que cada vez se está realizando un mayor número de ataques \emph{botnets} a dispositivos móviles, debido a que estos tienen muchos sensores que son atractivos para los atacantes y a los que se puede acceder de manera sencilla a través de las aplicaciones. El principal objetivo del artículo es exponer el potencial que tiene este tipo de ataques y el peligro que puede suponer, puesto que puede ser aplicado para erradicar organizaciones criminales pero también puede ser usado por ciberdelincuentes. En el artículo se va mostrando un ejemplo de ataque \emph{botnet} para mostrar la localización de diferentes dispositivos móviles.




\chapter{Introducción}

 Un \emph{botnet} se compone de dos partes: el cliente (que es a quien se ataca) y el servidor (que es quien realiza el ataque y quien recoge los datos). Al comienzo del artículo se muestra una breve introducción a los ataques a múltiples objetivos y la el por qué de realizarlo sobre dispositivos móviles. A continuación muestra una implementación del ataque donde se generan varias fases: 

\begin{description}
\item [Recoger información]: Como se puede recoger información de un dispositivo a través de la aplicaión \emph{Android}, que es el cliente del \emph{botnet}. En esta fase se muestra un ejemplo de una modificación del código de una aplicación para poder leer datos del dispositivo a través de la geolocalización.

\item [Almacenamiento y gestión de la información]: En esta fase se describe el procedimiento a seguir para almacenar la información que ha sido recogida a través del ataque. Para ello se puede usar tanto \emph{PHP} como \emph{MySQL} ya que ambos están instalados en la mayoría de los servidores de internet. En el artículo se indica que para almacenar la información de cada dispositivo lo mejor es crear una tabla por dispositivo cuya clave indentificativa sea el número \emph{IMEI}, ya que es un número único e identificativo para cada dispositivo.

\item [Mostrar la información]: En este fase se describe brevemente como poder mostrar en un página la información que ha sido recogida. Para ello se necesita generar código dinámico a través de \emph{Javascript} incrustado en código \emph{PHP}. Para acceder a los datos almacenados se hace una consulta a la base de datos a través de el comando SELECT a la base de datos del dispositivo del que queramos recuperar sus datos. Todos los nombres de las tablas son almacenados en un array para poder hacer las consultas a la base de datos. Para mostar la información en una web, se incluye la cabecera de \emph{HTML} de una página web para inicializar la \emph{API} de \emph{Google Maps} y a través de \emph{PHP} podemos mostrar diferentes iconos por cada \emph{botnet} en la página web y así poder diferenciar la información.

\item [Información de verificación]: En objetivo de esta fase es conocer el comportamiento de los usuarios que están siendo atacados por un \emph{botnet}. Se desea conocer si un persona infectada viaja en autobús, en tren o simplemente camina o está parado. Para ello se debe determinar la velocidad de movimiento del infectado. Por lo tanto, el problema de este ataque es conseguir suficiente información como para poder determinar el comportamiento de la persona a la que se ataca. Lo primero que se debe hacer es crear una nueva tabla donde, por cada instante de tiempo, realizar una verificación de la información capturada de diferentes dispositivos. Esto nos va a facilitar el proceso de gestión de los datos de diferentes objetivos a la vez. Cuando queramos consultar la información de verificación debemos indicar que queremos mostrar la información de manera ordenada en función del instante de tiempo para poder analizar la información de manera eficiente.

\item [Determinar puntos de encuentro entre dispositivos]: En esta fase se describe el proceso para poder determinar el momento en el cual dos dispositivos pueden estar en mismo lugar. Para ello se hace uso del algoritmo de \emph{k-means}. En artículo se muestra un ejemplo de implementación del algoritmo donde lo primero que se hace es seleccionar la información de los dispositivos que se desean analizar y almacenarlo en un cluster. El algoritmo \emph{k-means} puede ser aplicado de manera recursiva mientras los clusters no cumplan con las especificaciones deseadas. Si cumplen con los requisitos la primera vez basta con aplicarlo en una sola ocasión. El algoritmo es desarrollado en \emph{PHP} y necesita implementar una función que compruebe que el cluster cumple con los requisitos especificados. Los clusters seleccionados son concatenados en un array único para poder determinar de una manera más sencilla los puntos de encuentro. En la implementación mostrada en el artículo, los centroides iniciales son calculados de manera aleatoria dentro del rango de los máximos y mínimos de longitud y latitud observados en los datos. Se calculan a través de este método para asegurar buenos resultados. Los demás centroides son calculados a través de una ecuación de distancias de puntos sobre una esfera a partir de sus longitudes y latitudes. Antes de calcular los nuevos centroides se transforman los puntos de longitud y latitud al eje cartesiano. En cada iteración del algoritmo se calcula el cluster a partir de los puntos donde cada distancia entre los puntos calculados es menor a la distancia máxima. El atacante decide cuando dos víctimas están cercanas en función de un radio de distancia. Para cada cluster se selecciona los posibles puntos de encuentro en función del tiempo y la distacia. Esta es la razón por la cual almacenamos la información de verificación en función del instante de tiempo. De esta manera podemos analizar las zonas donde hay posibilidades de que sean puntos de encuentro. Si no hay ningún resultado viable, significa que los datos capturados no nos permiten determinar un punto de encuentro.

\end{description}



\chapter{Trabajos previos} \label{tPrevios}

\section{When the Droid became the Bot}

Uno de los grandes problemas de la seguridad en la actualidad ha sido el desarrollo de \emph{botnets}. El \emph{botmaster} despliega el código malicioso a diferentes \emph{hosts} vulnerables. Cuando el sistema ha sido infectado, el dispositivo pasa a formar parte de la \emph{botnet}, comienza a buscar nuevos dispositivos vulnerables y a realizar otras prácticas ilegales.

Las actividades delictivas más habituales que realizan las \emph{botnets} son ataques de \emph{spam} y ataques de denegación de servicio (DDoS). En los últimos años, el uso de \emph{smartphones} ha crecido de manera exponencial, por ello, los criminales deciden infectar estos dispositivos para realizar los ataques expuestos anteriormente.

Con la aparición de la tercera generación de redes móviles (3G), los \emph{smartphones} empiezan a conectarse a Internet, con las ventajas y desventajas que implica. Si el dispositivo resulta infectado, el \emph{botmaster} tiene la capacidad de ejecutar diferentes acciones sobre sus esclavos, como pueden ser el envío de SMS, instalar y borrar aplicaciones, realizar llamadas \ldots Aprovechando esta funcionalidad, algunos de los ataques más habituales que ejecutan las \emph{botnets} son los siguientes:

\begin{description}
\item[\emph{Spyware.}] Este tipo de ataques se utiliza para recoger datos personales (nombres, direcciones, datos bancarios \ldots) del atacado. Esto se consigue con la lectura de mensajes, monitorizando la posición del dispositivo, analizando la actividad en Internet y escuchando conversaciones telefónicas.
\item[DDoS.] Ataques de denegación de servicio contra \emph{call centers} o diferentes webs.
\item[Ataques al núcleo de la red.] Se realizan ataques de \emph{flooding} a la red celular durante fechas importantes del año, como año nuevo, para colapsar el sistema. Se produce un cuello de botella en el HLR (\emph{Home location register}), que es la base de datos que contiene cada teléfono móvil de la red GSM, hasta forzar su fallo.
\end{description}

En el entorno de pruebas, se han utilizado tres dispositivos \emph{rooteados}, el \emph{botmaster}, la víctima de spam y el dispositivo infectado. El objetivo de la investigación es detectar al \emph{botmaster} analizando los SMS que recibe la víctima.

Se ha analizado el dispositivo afectado, mirando su tarjeta SIM, el almacenamiento interno y su tarjeta SD y no se han encontrado los mensajes de \emph{spam} recibidos. Esto se debe a que el \emph{malware} se ejecuta en las capas intermedias del dispositivo, en vez de en espacio de usuario, véase \ref{botLayer}.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.8]{previo1}
\includegraphics[scale=0.9]{previo2}
\caption{\emph{Bot layer}}
\label{botLayer}
\end{center}
\end{figure}

\section{Andbot: Towards Advanced Mobile Botnets}

Andbot es una \emph{botnet} avanzada que se ejecuta en dispositivos \emph{Android}. Sus características principales son las siguientes:

\begin{description}
\item[Sigilosa.] Utiliza el protocolo HTTP, solo tiene acceso a Internet en segundo plano.
\item[Robusta.] Resistente a la mayoría de técnicas de defensa (sumidero DNS, inyección de comandos, lista negra de IPs \ldots).
\item[Barata.] Bajo coste, bajo uso de datos y bajo gasto energético.
\item[Soporte para comandos.] \emph{Phishing} y filtrado, DDoS, robo de información, apagado y control de llamadas.
\end{description}

La parte más importante de una \emph{botnet} es el C\&{}C (\emph{Command and controle design}). Para autenticar comandos, Andbot utiliza el algoritmo RSA. Para enviar comandos a los dispositivos infectados, el \emph{botmaster} genera una imagen JPG en la que se incluye el comando encriptado y firmado, seguidamente se sube a un blog y se comprime la URL. Por otro lado, combina la nueva URL con la fecha de inicio y de expiración del comando. Finalmente, el dispositivo infectado descarga la imagen JPG, descifra el comando y lo ejecuta.

Las pruebas se han realizado en cuatros dispositivos \emph{Android} y se ha incluido el código malicioso dentro de un conocido juego. La primera vez que se ejecuta el juego, Andbot comienza ha realizar sus funciones en segundo plano. Después de reiniciar, el juego se inicia de forma automática y el código se ejecuta siempre que el dispositivo se encuentre en reposo.

Para hacer frente a esta Andbot se recomienda utilizar las técnicas defensivas habituales contra \emph{botnet}, como construir mecanismos de detección coordinados, realizar análisis en busca de comandos que utilicen las vulnerabilidades del sistema y ejecutar por primera vez el código en \emph{sandboxes}.

\section{A K-Means Clustering Algorithm}

El algoritmo K-means \cite{k-means} fue descrito por Hartigan en 1975. Este algoritmo tiene como objetivo dividir un conjunto $MxN$ en $K$ clusters. No se realiza la suma de los cuadrados de todas las particiones, excepto cuando $M$ y $N$ toman valores pequeños y $K=2$. Para el caso general, se busca una solución óptima local que requiera mover un punto de un cluster a otro para evitar la suma de cuadrados.

Este algoritmo necesita una serie parámetros de entrada para poder ejecutar correctamente, son los siguientes:

\begin{enumerate}
\item Matriz de entrada de $M$ puntos por $N$ dimensiones.
\item Matriz inicial de $K$ centroides por $N$ dimensiones.
\end{enumerate}


\chapter{Trabajos posteriores} \label{tPosteriores}

En los años siguientes al artículo original, se han realizado multitud de trabajos similares, ya que, el sistema operativo \emph{Android} es cada vez más popular y tiene mayor cuota de mercado. A continuación, se resumen algunos de estos.

\section{Android botnet detection: An integrated source code mining approach}

Este artículo propone diferentes técnicas para detectar las \emph{botnets} en \emph{Android} \cite{posterior1}. Para ello, se aplica ingeniería inversa. Se utiliza la herramienta \emph{dex2jar}, utilizada en el Módulo II, que convierte los ficheros descomprimidos .dex a .jar. Seguidamente, se utiliza la herramienta \emph{JD-GUI} para poder analizar el código fuente del .jar.

Para averiguar si la aplicación contiene código malicioso, se utilizan diferentes modelos predictivos de \emph{machine learning}. Se utilizan técnicas de minería de datos para analizar el código, se realizan estadísticas de las clases analizadas y se buscan palabras clave en el código (\emph{lock}, \emph{concurrent}, etc.). Algunos de los algoritmos que se utilizan en el estudio son:

\begin{itemize}
\item NaiveBayes.
\item K-NN.
\item J48.
\item RandomForest.
\item SMO.
\end{itemize}

Todos los algoritmos tienen un porcentaje de precisión superior al 80 \%{}. Sin embargo, se puede comprobar que el algoritmo que mejor se comporta para detectar código malicioso es el algoritmo K-NN. Los algoritmos se deben entrenar con las nuevas técnicas que implementen las \emph{botnets} para realizar modelos predictivos adecuados.

\section{Investigation into Google Play security mechanisms via experimental botnet}

En este artículo \cite{posterior2}, se introduce código malicioso para que el dispositivo \emph{Android} forme parte de una \emph{botnet} y se comprueban los mecanismos de seguridad que utiliza \emph{Google Play} para publicar aplicaciones.

Se introducen dos componentes en la aplicación, a priori inofensivos, pero que en realidad es el código malicioso de la \emph{botnet}. Se piden los permisos típicos (\emph{GPS}, Internet \ldots) al usuario cuando hace uso de la aplicación, pero, en realidad se utilizan para recopilar información.

El dispositivo infectado recibe un \emph{JSON} del \emph{C\&{}C} en el que se incluyen datos meteorológicos y variables que son utilizadas para configurar y realizar ataques. Se utiliza el algoritmo \emph{SHA-256} para comprobar que las variables de los componentes son iguales que las que recibe del \emph{JSON}.

La aplicación se puede publicar en \emph{Google Play} sin ningún problema, ya que, no se detecta código malicioso. Esto se debe a que la aplicación se conecta con el \emph{C\&{}C} cuando recibe el \emph{JSON}, en la llamada \emph{onCreate()}. Se protegen los componentes maliciosos con cifrado \emph{SHA-256} para evitar que se manipulen.



\chapter{Revisión crítica del artículo}

La lectura de este artículo nos ha resultado bastante interesante y útil, ya que trata de un tema tan importante como la seguridad en nuestros dispositivos. Como se ha mencionado en el artículo, cada vez se hace un mayor uso de los \emph{smartphones} y esto hace que los atacantes se sientan atraídos e intenten infectar nuestros dispositivos. Que en un artículo se mencione un procedimiento a través del cual se puede infectar un dispositivo y captar información del mismo hace que el lector se sienta identificado y preste atención al contenido del mismo. Además, pese a que incluye bastante porciones de código (lo cuál le hace ser aún más técnico), la mayor parte lectura se nos ha hecho amena y fácil de entender. La estructura del artículo es bastante buena donde, tras una breve introducción al mismo, en cada apartado se explica una de las fases del ataque. Esto hace que el lector no pierda en ningún momento la referencia de en que fase del ataque se encuentra. 

Como se ha mencionado antes, la mayor parte de la lectura se ha hecho amena. Sin embargo, a la hora de explicar el proceso de determinar puntos de encuentro a través del algoritmo de k-means la lectura se ha hecho algo más pesada, incluso se ha tenido que releer unas cuantas veces para entender de manera general el desarrollo del algoritmo. 

A pesar de que siempre que pensamos en ataques cibernéticos (en este caso de un botnet) pensemos que es para hacer el mal, en el artículo se deja bastante claro que el objetivo de este artículo no es enseñar a realizar un ataque botnet, si no de analizar el potencial de este sistema para combatir el crimen en el mundo. Por eso, mientras se leía el artículo, no ha dado la sensación de ser un manual para interesados en realizar ataques botnets, más bien una manera de describir como nuestro dispositivo puede ser infectado y el peligro que ello conlleva.

Además, a pesar de ser un artículo publicado hace 4 años, este tipo de ataques se siguen dando en la actualidad. Cada vez hay más teléfonos móviles funcionando en el mundo, por lo tanto hay más posibilidades de infectar dispositivos a través de este método y robar información del mismo. Es por ello, por lo que nos ha parecido un artículo interesante, el hecho de que a pesar del paso del tiempo (unos pocos años en materia de seguridad informática es un mundo) sigue siendo actual y aplicable en estos días.


\chapter{Conclusiones} \label{conclusiones}


\bibliography{Bibliografia}
\bibliographystyle{ieeetr}


\chapter{Información complementaria}
\section{Información básica del autor}
El autor de este artículo es Valentin Hamon. En el momento en el que escribió el artículo era estudiante e investigador del laboratorio de criptologia operacional y virología en ESIEA (\emph{École supérieure d'informatique, électronique, automatique}. Está graduado como Ingeniero de Seguridad Informática de Sistemas por la ESIEA. Actualmente trabaja en FAMOCO, empresa que ha ha desarrollado la primera solución transaccional Android del mundo para ayudar a las empresas a alcanzar sus objetivos de transformación digital.

Además de este artículo, anteriormente publicó otro titulado: \emph{Malicious URI Resolving in PDFs}, cuyo propósito es mostrar que el simple uso de una petición HTTP desde un PDF puede ser una buena herramienta  para un atacante. Además, este documento trata sobre cómo puede ser relativamente fácil reutilizar algunas vulnerabilidades ajenas al documento. 

\section{Información básica de la revista}

El artículo fue publicado en la revista \emph{Springer-Verlag}. \emph{Springer-Verlag} es la filial francesa de \emph{Springer}, fundada en 1986. Su sede se encuentra en París. Los temas tratados en sus publicaciones son del ámbito de la medicina, las matemáticas, la estadística, la informática y la ingeniería. Además de la publicación de revistas de carácter científico, \emph{Springer-Verlag} se dedica a la publicación de libros del ámbito de las ciencias y a comercializar la editorial Springer en Francia. 


\section{Planificación} \label{planificacion}

En la siguiente página se muestra la planificación temporal del proyecto realizado, para ello, se ha utilizado un diagrama de Gantt.

\thispagestyle{plain}
\begin{landscape}
  \vspace*{\stretch{1}}
  \resizebox{!}{.76\textheight}{
  \begin{ganttchart}[
  x unit= 25 mm,
  hgrid=true,
  time slot format={little-endian}
  ]{21.03.2019}{31.03.2019} 
  
	\gantttitlecalendar{month=name,day} \\
	
	\ganttmilestone{Inicio del proyecto}{21.03.2019}\\ 
  
	% Lectura y resumen de nuestro artículo
	\ganttgroup{Estudio del artículo}{22.03.2019}{25.03.2019} \\
	\ganttbar{Lectura}{22.03.2019}{23.03.2019}\\
	\ganttbar{Resumen}{23.03.2019}{25.03.2019} \\
	
	\ganttgroup{Trabajos previos y posteriores}{24.03.2019}{26.03.2019} \\
	\ganttbar{Lectura}{24.03.2019}{25.03.2019}\\
	\ganttbar{Resumen}{25.03.2019}{26.03.2019} \\
 
	\ganttgroup{Crítica y conclusión}{27.03.2019}{28.03.2019} \\
	\ganttbar{Revisión crítica}{27.03.2019}{28.03.2019}\\
	\ganttbar{Conclusiones}{28.03.2019}{28.03.2019} \\
	
	\ganttgroup{Preparación del documento}{29.03.2019}{31.03.2019} \\
	\ganttbar{Revisión}{29.03.2019}{29.03.2019}\\
	\ganttbar{Maquetado}{29.03.2019}{31.03.2019} \\
	
	\ganttmilestone{Entrega del proyecto}{31.03.2019}\\ 
	
	\ganttlink{elem0}{elem1}
	\ganttlink{elem2}{elem3}
	\ganttlink{elem5}{elem6}
	\ganttlink{elem3}{elem8}
	\ganttlink{elem3}{elem9}	
	\ganttlink{elem6}{elem9}
	\ganttlink{elem9}{elem11}
	\ganttlink{elem11}{elem12}
	\ganttlink{elem12}{elem13}
	
  \end{ganttchart}
  }
  \vspace*{\stretch{1}}
\end{landscape}

\appendix
\chapter*{Glosario} \label{glosario}

\begin{description}
\item[Android.] Sistema operativo para dispositivos móviles desarrollado por Google, basado en el kernel de Linux y de código abierto.
\item[API.] Application Programming Interface, conjunto de funciones que ofrece cierta biblioteca para ser utilizado por otro software como capa de abstracción.
\item[Botmaster.]  Individuo o sistema responsable del control de bots.
\item[Botnet.] Conjunto de \emph{bots} que se ejecutan de manera autónoma. El creador de la \emph{botnet} puede controlar los dispositivos infectados de manera remota.
\item[C\&{}C.] Command and Controle, software de control y comandos que utiliza el botmaster para controlar la red.
\item[DDoS.] Distributed Denial of Service, ataque de denegación de servicio que realiza múltiples peticiones hacia un único destino.
\item[GSM.] Global System for Mobile, sistema estándar y libre de telefonía digital.
\item[HLR.] Home Location Register, base de datos que contiene todos los dispositivos registrados en la red GSM.
\item[IMEI.] International Mobile Equipment Identity, código pregrabado en los móviles GSM que lo identifican unívocamente.
\item[JSON.] JavaScript Object Notation, es un formato de texto sencillo para el intercambio de datos. 
\item[Machine learning.] Subcampo de las ciencias de la computación y una rama de la inteligencia artificial, cuyo objetivo es desarrollar técnicas que permitan que las computadoras aprendan. 
\item[Phishing.] Proceso de ingeniería social que se utiliza para conseguir datos de usuarios de manera fraudulenta.
\item[Root.] Proceso que permite al usuario tener privilegios elevados (superusuario) para sobrepasar las limitaciones que impone el fabricante de hardware y software.
\item[RSA.] Sistema criptográfico de clave pública.
\item[Sandbox.] Aislamiento de procesos, es un mecanismo para ejecutar programas con seguridad y de manera separada.
\item[SHA-256.] Secure Hash Algorithm - 256, función hash de cifrado.
\item[SIM.] Subscriber Identity Module, almacena la clave de servicio del suscriptor usada para identificarse ante la red.
\end{description}


\end{document}


